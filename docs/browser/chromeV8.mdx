---
sideBar_position: 1
---

# 深入理解Chrome V8垃圾回收机制

:::tip
javascript这门语言的内存管理借鉴了Java，普通数据类型放在**栈**中,复杂数据类型存储在**堆**中，因此在垃圾回收机制上，两门语言的回收过程也极为相似
:::

export const Image = ({path}) => {
    return (
        <img src={path} style={{margin: "10px 0",boxShadow:"2px 2px 30px #c7ccd7",}}></img>
    )
}

## JavaScript 的内存管理

与其他语言的手动管理内存的语言不同，在JavaScript中，当我们创建变量的时候，系统会自动给变量分配相应的内存

```js
let n = 123; // 给数值变量分配内存
let s = "azerty"; // 给字符串分配内存

let o = {
  a: 1,
  b: null
}; // 给对象及其包含的值分配内存

// 给数组及其包含的值分配内存（就像对象一样）
let a = [1, null, "abra"]; 

function f(a){
  return a + 2;
} // 给函数（可调用的对象）分配内存

// 函数表达式也能分配一个对象
someElement.addEventListener('click', function(){
  someElement.style.backgroundColor = 'blue';
}, false);
```

在JavaScript中，数据类型分为两类，简单类型和引用类型，对于简单类型，内存是保存在**栈（stack）**空间中，复杂数据类型，内存是保存在**堆（heap）**空间中。

* 基本类型：这些类型在内存中分别占有固定大小的空间，他们的值保存在栈空间，我们通过按值来访问
* 引用类型：引用类型，值大小不固定，栈内存中存放地址指向堆内存中的对象。是按引用访问的。

## 为什么需要垃圾回收？

在Chrome中，v8被限制了内存的使用**（64位约1.4G/1464MB ， 32位约0.7G/732MB）**，所以例如js执行大量的递归函数时，浏览器会报错堆栈溢出。那为什么要限制呢？

1. 表层原因是，V8最初为浏览器而设计，不太可能遇到用大量内存的场景
2. 深层原因是，V8的垃圾回收机制的限制（如果清理大量的内存垃圾是很耗时间，这样回引起JavaScript线程暂停执行的时间，那么性能和应用直线下降）

所以JavaScript程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。

前面说到**栈内的内存，操作系统会自动进行内存分配和内存释放**，而**堆中的内存，由JS引擎（Chrome的V8）手动进行释放**

## Chrome垃圾回收算法

在JavaScript中，其实绝大多数的对象存活周期都很短，大部分在经过一次的垃圾回收之后，内存就会被释放掉，而少部分的对象存活周期将会很长，一直是活跃的对象，不需要被回收

为了提高回收效率，V8 将堆分为两类`新生代`和`老生代`，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象

新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收

* 副垃圾回收器 - Scavenge: 主要负责**新生代**的垃圾回收
* 主垃圾回收器 - Mark-Sweep & Mark-Compact: 主要负责**老生代**的垃圾回收

### 新生代垃圾回收器 - Scavenge

在JavaScript中，任何对象的声明分配到的内存，将会先被放置在**新生代**中，而因为**大部分对象在内存中存活的周期很短**，所以需要一个效率非常高的算法。

在新生代中，主要使用**Scavenge**算法进行垃圾回收，**Scavenge**算法是一个典型的牺牲空间换取时间的复制算法，在占用空间不大的场景上非常适用

Scavange算法将新生代堆分为两部分，分别叫`from-space`和`to-space`，工作方式也很简单，就是将`from-space`中**存活的活动对象**复制到`to-space`中，并将这些对象的内存有序的排列起来，然后将`from-space`中的非活动对象的内存进行释放，完成之后，将`from space` 和`to space`进行互换，这样可以使得新生代中的这两块区域可以重复利用

<Image path="https://img-blog.csdnimg.cn/0b909b3ceebc473b9c2aaf39bb7c32d9.png"/>

简单的描述就是：
* 标记 from space 区的活动对象和非活动对象
* 复制 from space 的**活动对象**到 to space 并对其进行排序
* 释放 from space 区域
* 将from space和to space翻转，也就是原来的from变成to，to变成from

那么，垃圾回收器是怎么知道哪些对象是活动对象和非活动对象的呢？

有一个概念叫对象的可达性，表示从初始的根对象（window，global）的指针开始，这个根指针对象被称为根集（root set），从这个根集向下搜索其子节点，被搜索到的子节点说明该节点的引用对象可达，并为其留下标记，然后递归这个搜索的过程，直到所有子节点都被遍历结束，那么没有被标记的对象节点，说明该对象没有被任何地方引用，可以证明这是一个需要被释放内存的对象，可以被垃圾回收器回收。

在新生代中，还进一步进行了细分，分为`nursery`子代和`intermediate`子代两个区域，一个对象第一次分配内存时会被分配到新生代中的`nursery`子代，如果进过下一次垃圾回收这个对象还存在新生代中，这时候我们移动到 `intermediate` 子代，再经过下一次垃圾回收，如果这个对象还在新生代中，副垃圾回收器会将该对象移动到老生代中，这个移动的过程被称为晋升

### 老生代垃圾回收 - Mark-Sweep & Mark-Compact

新生代空间的对象在满足一定条件后，晋升到老生代空间中，所以在老生代中的对象，都已经至少经历过一次或多次的回收，所以它们存活的几率会很大，如果这个时候再使用`scanvge`算法的话，会出现两个问题：

* scavenge为复制算法，重复复制**大量的活动活动对象**会使得效率底下
* scavenge是牺牲空间来换时间效率的算法，而老生代支持的容量较大，会出现空间资源浪费问题

所以在老生代空间中采用了 `Mark-Sweep（标记清除）` 和 `Mark-Compact（标记压缩）` 算法。

**Mark-Sweep**

Mark-Sweep处理时分为两阶段，标记阶段和清除阶段，看起来和Scavenge类似

不同的是，Scavenge算法是复制活动对象，而由于在老生代中活动对象占大多数，所以Mark-Sweep在标记了活动对象和非活动对象之后，直接把非活动对象清除

* 标记阶段： 对老生代进行第一次扫描，标记活动对象
* 清理阶段： 对老生代进行第二次扫描，清除未被标记的对象，即
