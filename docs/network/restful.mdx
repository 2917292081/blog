---
sideBar_position: 1
---

# RESTFul API

###  一、:rocket:起源：

export const Image = ({path}) => {
    return (
        <div style={{textAlign:"center"}}>
            <img style={{boxShadow: "2px 2px 30px #444",margin:"40px 0"}} src={path}></img>
        </div>
    )
}

REST这个词，是[Roy Thomas Fielding](http://en.wikipedia.org/wiki/Roy_Fielding)在他2000年的博士论文中提出的

<Image path="https://img-blog.csdnimg.cn/7e55a11f1a7641c68de25d791969d3f7.webp"/>

Fielding是一个非常重要的人，他是HTTP协议（1.0版和1.1版）的主要设计者、Apache服务器软件的作者之一、Apache基金会的第一任主席。所以，他的这篇论文一经发表，就引起了关注，并且立即对互联网开发产生了深远的影响

###  二、:bowling:RESTful 架构：

* 每一个URI代表一种资源
* 对资源操作，实现状态转换。常用HTTP方法操作
* 由客户端对服务器资源进行操作

### 三、:whale2:URL Request：

一个URL设计，需要简单，易懂，看到URL就能知道这个URL的意思，也就是自解释，自描述。

看看http url的设计，分为协议，域名，path，method，参数。

我们应该可以得到启发，它其实就是根据http协议而来。

比如获取雇员url：GET /users， 动作方法+path

比如 GET 操作：

> GET http://example.com/users 获取所有的员工信息

> GET http://example.com/users/23 获取员工id=23的信息

:::tip
RESTful API 是基于REST架构设计理念之下利用http协议来描述接口操作接口
:::

|方法/资源|	`http://example.com/users`  |	`http://example.com/users/23` |
|---|---|---|
|GET	|获取所有的用户信息|	获取用户id为23的信息|
|POST|	在所有用户信息中创建/追加一个新的用户|	在id=23号用户新增信息|
|PUT|	更新该组用户信息|	更新id=23号的用户信息|
|DELETE|	删除所有的用户信息|	删除id=23号用户信息|
|PATCH	|更新所有用户部分信息	|更新id=23号用户信息|

### 三、:bow_and_arrow:实例：

常见错误：

比如新建一个用户：POST http://example.com/users/22 ，这种形式是错误的，应该用
POST http://example.com/users

* 用复数形式描叙资源

上面的 example.com/users，users复数形式，而且是名词。因为常见的操作是一个集合。所以一般建议用复数形式。不推荐使用 example.com/user/1这种形式，而是推荐使用example.com/users/1 复数这种形式。

错误的表示形式：

>GET http://example.com/getusers - 不要使用这种带有get动词的形式

getusers 前面带一个get是多余的，因为http请求的动作就是GET，不用写多余的动作了。如果这样写的话，很容易造成大家理解api不统一。有可能前端和后端人员各自为政，用不同的动词来操作url，造成大家开发理解的不统一。

类似的还有：

>/createUsers
>/updateUserInfo
>/deleteUser?id=2

>统一标准：前后端人员统一用http规定的几个动作来进行url相关的操作。不需要在url后面加多余的动作名词。统一用一个标准，这样前后端人员理解起来也能统一思想，便于大家协作开发。

* url的层级

在操作资源的时候，最简单的操作是CURD，但是资源之间相互关联也很常见，资源嵌套也很常见，比如查找id为10的用户所有文章，这个URL如何设计？
一种设计：

>GET /users/10/articles

获取article的id=3文章

>GET /users/10/articles/3

有人推荐这种方案，这种形式的 URI 一定程度上描述了 user 与 article 之间的一对多关系，但同时，我们就不太能够分清当前端点返回的数据到底是 user 类型还是 article 类型。
这种设计语义不明确，也不利于扩展。

另一种设计，除了第一级，其他级别都用查询字符串表达：

> GET /articles?user_id=10

推荐使用这种方案。

> 比如用户发布文章：GET /atticles?user_id=10&published=true

* 域名的设计

>比如我们用独立的api域名：api.example.com。
>或者在域名后面加 api，这种形式 example.com/api/users 。
>这样有利于以后我们迁移，扩展。

* 版本号 

考虑到系统的变化，迭代，和兼容性，在API中引入版本号。
是否在URL中加入版本号，有一个争论。
有的认为不要在URL中加入版本号，可以在请求头信息中加入。因为不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个URI。

> Accept: application/example.com+json; version=3

有的则认为在URL中放入版本号，操作简单。在api变更时候，更容易操作些：

> GET api.example.com/v1/users

根据个人来选择，一般推荐在url中写上版本号。

**筛选过滤复杂参数-复杂业务场景**

对可选的、复杂的参数，使用查询字符串querystring（？）

比如说有一些复杂的业务场景，比如对获取的资源在进行条件筛选，还有排序，分页等等
对于这些场景，RESTful api又怎么设计？ 用querystring

* 过滤

比如某一个用户已经发表的文章：

>GET /users/10/posts?state=published 

>GET /users/10/posts?published=true

* 分页

>比如用户分页：
>GET /users?page=1&page_size=10

>在加条件，某一个用户已经发表的文章太多，需要分页：

>GET /users/10/posts?published=true&page=2&page_size=10

* 多字段，不同排序

>针对多个字段，不同的排序：
>搜索用户，并按照注册时间升序、活跃度降序

>GET /users?q=key&sort=create_time_asc,liveness_desc

* 显示某些字段

>GET /users?fields=id,title,desc;