---
slug: Row
title: Row
authors: lsh
tags: [element,Row]
---

>`row`通过基础的 24 分栏，迅速简便地创建布局

export const Image = ({path}) => {
    return (
        <img style={{boxShadow: "2px 2px 30px #c7ccd7"}} src={path}></img>
    )
}

<Image path="https://img-blog.csdnimg.cn/1d6804f15e9f439fa035c731f683863c.png"/>

## render函数的优势

row组件采用了render函数实现，这样做的好处是可以渲染用户指定的标签

:::info
例如，下面的做法

```html
<template>
    <h1 v-if="tag == 'h1'"><slot><slot></h1>
    <h2 v-if="tag == 'h2'"><slot><slot></h2>
    <h3 v-if="tag == 'h3'"><slot><slot></h3>
    <h4 v-if="tag == 'h4'"><slot><slot></h4>
    <h5 v-if="tag == 'h5'"><slot><slot></h5>
    <h6 v-if="tag == 'h6'"><slot><slot></h6>
</template>
```
肯定不如这样灵活:
```js
export default {
    render(h) {
        return h(this.tag,{
            
        },this.$slots.default)
    }
}
```
:::

## 源码的做法

```js
render(h) {
    return h(this.tag, {
        class: [
            'el-row',
            this.justify !== 'start' ? `is-justify-${this.justify}` : '',
            this.align !== 'top' ? `is-align-${this.align}` : '',
            { 'el-row--flex': this.type === 'flex' }
        ],
        style: this.style
    }, this.$slots.default);
  }
```

props如下：
```js
props: {
    tag: {
        type: String,
        default: 'div'
    },
    gutter: Number,
    type: String,
    justify: {
        type: String,
        default: 'start'
    },
    align: {
        type: String,
        default: 'top'
    }
  },
```
根据传入的`justify、align、type`渲染对应的Css类

`style`的来源是计算属性

```js title="根据gutter计算外边距"
computed: {
    style() {
        const ret = {};

        if (this.gutter) {
            ret.marginLeft = `-${this.gutter / 2}px`;
            ret.marginRight = ret.marginLeft;
        }

        return ret;
    }
},
```

:::tip
关于**margin**负值的妙用，将会在`Col`篇中讲解[跳转col:triangular_flag_on_post:](/element/Col#关于gutter)
:::

